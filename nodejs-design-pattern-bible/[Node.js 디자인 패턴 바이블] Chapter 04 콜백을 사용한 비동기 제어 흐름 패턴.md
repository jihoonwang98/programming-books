# [Node.js 디자인 패턴 바이블] Chapter 04 콜백을 사용한 비동기 제어 흐름 패턴



**이번 절에서 배울 것들**

- 비동기 프로그래밍에 대한 과제
- 콜백 지옥을 피하는 것과 콜백 모범 사례들
- 연속적 실행, 연속적 반복, 병렬 실행 그리고 제한된 병렬 실행에서 흔히 다루는 비동기 패턴



**목차**

- 4-1 비동기 프로그래밍의 어려움
  - 간단한 웹 스파이더 만들기
  - 콜백 지옥 (Callback hell)
- 4-2 콜백 모범 사례와 제어 흐름 패턴
  - 콜백 규칙
  - 콜백 규칙 적용
  - 순차 실행
  - 병렬 실행
  - 제한된 병렬 실행
- 4-3 비동기 라이브러리



## 도입

- 동기식 프로그래밍 스타일을 사용하는 플랫폼에서 Node.js와 같이 **연속 전달 스타일(CPS)**과 비동기 API를 일반적으로 사용하는 플랫폼으로의 적응은 쉽지 않을 수 있습니다.
- 비동기 코드는 구문이 실행되는 순서를 예측하기 어렵게 할 수 있습니다.
- 일련의 파일들을 반복 탐색하거나, 작업을 순서대로 실행하거나, 일련의 작업들이 완료될 때까지 기다리는 것과 같은 간단한 문제라도 비효율적이고 가독성이 떨어지는 것을 피하기 위해서 개발자에게는 새로운 접근법과 기술들이 요구됩니다.
- 비동기 제어 흐름을 다루기 위해 콜백을 사용할 때 가장 흔히 하는 실수는 콜백 지옥에 빠지거나 코드가 간단한 루틴에서조차 가독성이 떨어지고 유지하기 힘들어져서 수직적이라기보다 수평적으로 커지는 일입니다.



- 이 장에서는 몇 가지 규칙과 패턴을 사용하여 실제로 어떻게 콜백을 능숙하게 제어하며, 깔끔하게 관리 가능한 비동기 코드를 작성할 수 있는지 살펴볼 것입니다.
- 콜백을 올바르게 다루는 법을 알게 되는 것은 프라미스와 async/await와 같이 최근에 쓰이는 접근법을 사용하기 위한 초석이 될 것입니다.





## 4-1 비동기 프로그래밍의 어려움

- JS에서는 비동기 코드에 대한 제어를 놓치는 일이 정말 흔하게 일어납니다.
- 클로저와 익명 함수의 in-place 정의는 개발자가 코드베이스 지점들을 옮겨 다니지 않고 원할한 프로그래밍을 하게 해줍니다.
- 이는 **KISS(Keep It Simple, Stupid)** 원칙과 완전하게 부합합니다.
- 이는 코드가 매끄럽게 흘러가게 해주고 이를 짧은 시간에 정의할 수 있게 해줍니다.
- 불행히도 모듈화, 재사용성 그리고 유지보수성과 같은 특성들을 희생하는 것은 콜백의 중첩을 통제할 수 없이 급증하게 하고 함수의 크기가 커지며 구성 또한 엉망이 되게 합니다.
- 대부분의 경우 in-place 콜백을 만드는 것이 절대적으로 요구되는 것은 아닙니다.
- 그래서 비동기 프로그래밍과 관련된 문제보다는 규칙 문제가 더 중요합니다.
- 코드가 다루기 힘들어지는지 좋아지고 있는지를 인지하며 그것이 통제하기 힘들어지는 것을 미리 알고 그에 따라 최선의 해결책을 가지고 행동하는 것이 전문가와 초보자의 차이입니다.



### 4-1-1 간단한 웹 스파이더 만들기

- 이야기를 풀어나가기 위해서 우리는 웹 URL을 입력으로 받아 해당 URL의 내용을 로컬 파일로 다운로드하는 간단한 콘솔용 애플리케이션인 웹 스파이더를 만들어 보겠습니다.
- 이 장에서 소개될 코드에서는 몇 가지의 npm 종속성들이 사용됩니다.
  - superagent: 스트림라인 HTTP 호출 라이브러리
  - mkdirp: 재귀적으로 디렉터리를 만드는 작은 유틸리티
- 또한 우리는 애플리케이션에서 사용할 헬퍼들을 가지고 있는 `./utils.js`라는 로컬 모듈을 종종 참조할 것입니다.
  - https://github.com/PacktPublishing/Node.js-Design-Patterns-Third-Edition 참고



- 애플리케이션의 핵심 기능은 `spider.js`라는 모듈 안에 있습니다.
- 사용할 모든 종속성들을 로드하는 것으로 시작해보겠습니다.

```js
import fs from 'fs'
import path from 'path'
import superagent from 'superagent'
import mkdirp from 'mkdirp'
import { urlToFilename } from './utils.js'
```

- 다음으로 다운로드할 URL과 다운로드 프로세스가 완료될 때 호출될 콜백 함수를 취하는 `spider()`라는 새로운 함수를 만듭니다.

```js
export function spider(url, cb) {
  const filename = urlToFilename(url)
  fs.access(filename, err => {     // (1)
    if (err && err.code === 'ENOENT') {
      console.log(`Downloading ${url} into ${filename}`)
      superagent.get(url).end((err, res) => {     // (2)
        if (err) {
          cb(err)
        } else {
          mkdirp(path.dirname(filename), err => {    // (3)
            if (err) {
              cb(err)
            } else {
              fs.writeFile(filename, res.text, err => {    // (4)
                if (err) {
                  cb(err)
                } else {
                  cb(null, filename, true)
                }
              })
            }
          })
        }
      })
    } else {
      cb(null, filename, false)
    }
  })
}
```

- 여기서 많은 것들이 진행됩니다. 단계별로 좀 더 상세하게 다루어 보겠습니다.

  1. 해당하는 파일이 존재하는지 확인하여 해당 URL에서 이미 다운로드를 했는지 검사합니다. err가 정의되어있고 타입이 ENOTENT이라면 파일이 존재하지 않으므로 파일 생성에 문제가 없습니다.

  ```js
  fs.access(filename, err => ...
  ```

  2. 파일을 찾을 수 없을 경우 해당 URL은 다음의 코드를 통해 다운로드됩니다.

  ```js
  superagent.get(url).end((err, res) => ...
  ```

  3. 그 다음 파일이 저장될 디렉터리가 있는지 확인합니다.

  ```js
  mkdirp(path.dirname(filename), err => ...
  ```

  4. 마지막으로 HTTP 응답의 내용을 파일 시스템에 씁니다.

  ```js
  fs.writeFile(filename, res.text, err => ...
  ```



- 우리의 웹 스파이더 애플리케이션을 완성하기 위해서 URL을 입력으로(우리의 경우, 커맨드라인에서 인자를 읽습니다) 제공하여 `spider()` 함수만 호출하면 됩니다.
  - `spider()` 함수는 우리가 방금 정의한 파일에서 export 됩니다.
- 이제 커맨드라인에서 직접 호출될 수 있는 새로운 파일 `spider-cli.js`을 만듭니다.

```js
import { spider } from './spider.js'

spider(process.argv[2], (err, filename, downloaded) => {
  if(err) {
    console.error(err)
  } else if (downloaded) {
    console.log(`Completed the download of "${filename}"`)
  } else {
    console.log(`"${filename}" was already downloaded`)
  }
})
```



- 이제 웹 스파이더 애플리케이션을 사용할 준비가 되었습니다. 
- 먼저 utils.js 모듈과 프로젝트 디렉터리에 있는 전체 종속성 목록을 가지고 있는 package.json이 있는지 확인한 후, 다음 명령을 통해 모든 종속성을 설치합니다.

```shell
npm install
```



- 이제 웹 페이지의 내용을 다운로드하기 위해 커맨드에서 다음과 같이 `spider-cli.js` 모듈을 실행합니다.

```shell
node spider-cli.js http://www.example.com
```



- 다음 섹션에서는 이 코드의 가독성을 어떻게 향상시키고 가능한 어떻게 콜백 기반 코드를 깔끔하고 가독성 좋게 유지할 수 있는지 배워보겠습니다.



### 4-1-2 콜백 지옥 (Callback hell)

- 앞에서 정의한 `spider()` 함수를 살펴보면, 우리가 구현한 알고리즘이 정말 간단하지만 결과적으로는 코드에 여러 수준의 들여쓰기가 존재하므로 읽기가 매우 어렵다는 것을 알 수 있습니다.
- 직접 스타일의 블로킹 API로 유사한 기능을 구현하는 것이 더 간단할 수 있으며 코드의 가독성이 훨씬 더 올라갈 것이 분명합니다.
- 그러나 비동기식 CPS를 사용하는 것은 또 다른 이야기이며, in-place 콜백 정의를 잘못 사용하는 것은 좋지 않은 코드를 야기할 수 있습니다.



- 많은 클로저와 in-place 콜백 정의가 코드의 가독성을 떨어뜨리고 관리할 수 없는 덩어리로 만드는 상황을 **콜백 지옥**이라고 합니다.
- 이것은 Node.js와 JavaScript에서 일반적으로 가장 잘 알려져 있는 안티 패턴 중 하나입니다.

```js
asyncFoo(err => {
	asyncBar(err => {
		asyncFooBar(err => {
			...
		})
	})
})
```

- 이런 식으로 작성된 코드가 깊은 중첩으로 인해 피라미드 같은 모양을 취한다는 것을 볼 수 있습니다.
- 그 때문에 이것이 한편으로는 **죽음의 피라미드 (pyramid of doom)**로 알려진 이유입니다.



- 위와 같은 코드에서 가장 분명하게 드러나는 문제점은 **가독성**입니다.
  - 중첩이 너무 깊어서 함수가 어디서 끝나고 또 다른 함수는 어디서 시작하는지 추적하는 것이 거의 불가능합니다.
- 또 다른 문제는 각 스코프에서 사용되는 **변수이름의 중복**이 발생한다는 점입니다.
  - 흔히 변수의 내용을 설명하기 위해서 유사하거나 동일한 이름을 사용해야 하기 때문입니다.
  - 가장 좋은 예가 각 콜백이 수신하는 인자인 err입니다.
- 그리고 클로저가 성능 및 메모리 소비 측면에서 부정적인 영향을 미칠 수 있다는 것을 명심해야 합니다.
  - 또한 그것들은 식별하기 쉽지 않은 메모리 누수를 만들어 냅니다.
  - 실제로 활성 클로저에 의해 참조되는 컨텍스트가 가비지(garbage) 수집 시 유지된다는 것을 잊어서는 안됩니다.



- `spider()` 함수를 보면 그것이 콜백 지옥 상황을 명확히 나타내고 방금 설명한 모든 문제들을 가지고 있다는 것을 알아차릴 수 있습니다.
- 다음 섹션에서 패턴과 기술들을 가지고 고쳐보도록 하겠습니다.



## 4-2 콜백 모범 사례와 제어 흐름 패턴

- 콜백 지옥에 대한 첫 번째 예를 보았고, 이제 분명히 피해야 함을 알게 되었습니다. 
- 그러나 비동기 코드를 작성할 때 주의해야 할 사항은 그것뿐만이 아닙니다.
- 실제로 일련의 비동기 작업들의 흐름을 제어하려면 특정 패턴과 기법을 사용해야만 하는 상황이 있습니다.
- 특히 외부 라이브러리를 사용하지 않고 일반 JavaScript만 사용하는 경우에는 더욱 그렇습니다.
- 예를 들어, 순서에 따라 비동기 작업을 적용하여 컬렉션을 반복하는 것은 배열에 `forEach()`를 호출하는 것과 같이 쉬운 것이 아니며 실제로는 재귀와 유사한 기술을 필요로 합니다.



- 이 섹션에서는 콜백 지옥을 피하는 방법뿐만 아니라, 단순하고 간단한 JavaScript만 사용하여 가장 일반적인 제어 흐름 패턴을 구현하는 방법에 대해서도 배우게 될 것입니다.



### 4-2-1 콜백 규칙

- 비동기 코드를 작성할 때 명심해야 할 첫 번째 규칙은 콜백을 정의할 때 in-place 함수의 정의를 남용하지 않는 것입니다.
- 모듈화 및 재사용성과 같은 문제에 대한 추가적인 사항을 고려할 필요가 없어 매력적이겠지만, 이는 장점보다 단점이 더 많을 수 있는 방식이라는 것을 이미 앞에서 살펴보았습니다.
- 대부분의 경우 콜백 지옥 문제를 해결하기 위한 어떤 라이브러리나 멋진 기술 혹은 패러다임의 변화가 필요한 것은 아니며, 간단하고 일반적인 상식이면 충분합니다.



- 다음은 중첩수준을 낮게 유지하고 일반적으로도 코드 체계를 개선하는데 도움이 되는 몇 가지 기본 원칙입니다.
  - 가능한 빨리 종료합니다. 문맥에 따라 `return`, `continue`, `break`를 사용하면 `if ... else`문을 모두 작성(및 중첩)하는 대신 현재 구문을 즉시 종료할 수 있습니다. 이렇게 하면 얕은 수준으로 코드를 유지하는데 도움이 됩니다.



































